/*
 * GridLib - A reusable TypeScript library for spreadsheet-like grid functionality using only div elements.
 * Fully generated by AI using roo cline Extension
 * AI Model : Gemini 2.0 flash-exp
 */

interface Cell {
    value: string;
    element: HTMLDivElement;
    selected: boolean;
    editing?: boolean;
}

interface GridConfig {
    rows: number;
    cols: number;
    freezeRows: number;
    freezeCols: number;
}

class Grid {
    private config: GridConfig;
    private cells: Cell[][] = [];
    private container: HTMLDivElement;
    private isDragging = false;
    private startCell: Cell | null = null;
    private copiedCells: Cell[] = [];
    private headerCells: Cell[] = [];
    private resizeHandle: HTMLDivElement | null = null;
    private resizingColIndex: number | null = null;
    private startX: number = 0;
    private startWidth: number = 0;
    private rowNumberCells: Cell[] = [];

    constructor(config: GridConfig) {
        this.config = config;
        this.container = document.querySelector('[data-grid]') as HTMLDivElement;
        this.init();
    }

    private init() {
        console.log('Grid initialized');
        this.setGridColumns();
        this.createGrid();
        this.setupEventListeners();
    }

    private setGridColumns() {
        this.container.style.gridTemplateColumns = `50px repeat(${this.config.cols}, 100px)`;
    }

    private createGrid() {
        this.createHeaderRow();
        for (let row = 0; row < this.config.rows; row++) {
            this.cells[row] = [];
            const rowNumberCell = this.createRowNumberCell(row);
            this.rowNumberCells.push(rowNumberCell);
            this.container.appendChild(rowNumberCell.element);
            for (let col = 0; col < this.config.cols; col++) {
                const cell = this.createCell(row, col);
                this.cells[row][col] = cell;
                this.container.appendChild(cell.element);
                if (row < this.config.freezeRows) {
                    cell.element.classList.add('frozen-row');
                }
                if (col < this.config.freezeCols) {
                    cell.element.classList.add('frozen-col');
                }
            }
        }
    }

    private createHeaderRow() {
        this.headerCells = [];
        const emptyHeaderCell = this.createHeaderCell(-1);
        emptyHeaderCell.element.textContent = '';
        this.headerCells.push(emptyHeaderCell);
        this.container.appendChild(emptyHeaderCell.element);
        for (let col = 0; col < this.config.cols; col++) {
            const headerCell = this.createHeaderCell(col);
            this.headerCells.push(headerCell);
            this.container.appendChild(headerCell.element);
            if (col < this.config.freezeCols) {
                headerCell.element.classList.add('frozen-col');
            }
        }
    }

    private createHeaderCell(col: number): Cell {
        const el = document.createElement('div');
        el.classList.add('grid-header-cell');
        if (col !== -1) {
            el.textContent = this.getColumnHeaderTitle(col);
        }
        const resizeHandle = document.createElement('div');
        resizeHandle.classList.add('resize-handle');
        el.appendChild(resizeHandle);
        const cell: Cell = {
            value: '',
            element: el,
            selected: false,
        };
        return cell;
    }

    private createRowNumberCell(row: number): Cell {
        const el = document.createElement('div');
        el.classList.add('grid-row-number-cell');
        el.textContent = (row + 1).toString();
         const cell: Cell = {
            value: '',
            element: el,
            selected: false,
        };
        return cell;
    }

    private getColumnHeaderTitle(col: number): string {
        let title = '';
        let num = col;
        while (num >= 0) {
            title = String.fromCharCode(65 + (num % 26)) + title;
            num = Math.floor(num / 26) - 1;
        }
        return title;
    }

    private createCell(row: number, col: number): Cell {
        const el = document.createElement('div');
        el.classList.add('grid-cell');
        el.tabIndex = 0;
        const cell: Cell = {
            value: '',
            element: el,
            selected: false,
        };
        return cell;
    }

    private setupEventListeners() {
        this.container.addEventListener('mousedown', this.handleMouseDown.bind(this));
        this.container.addEventListener('mousemove', this.handleMouseMove.bind(this));
        this.container.addEventListener('mouseup', this.handleMouseUp.bind(this));
        this.container.addEventListener('keydown', this.handleKeyDown.bind(this));
        this.container.addEventListener('dblclick', this.handleDoubleClick.bind(this));
        this.container.addEventListener('copy', this.handleCopy.bind(this));
        this.container.addEventListener('paste', this.handlePaste.bind(this));
        this.container.addEventListener('mousedown', this.handleResizeStart.bind(this));
        this.container.addEventListener('mousemove', this.handleResizeMove.bind(this));
        this.container.addEventListener('mouseup', this.handleResizeEnd.bind(this));
    }

    private handleMouseDown(e: MouseEvent) {
        this.isDragging = true;
        const cell = this.getCellFromElement(e.target as HTMLDivElement);
         if (cell && cell.element.classList.contains('grid-header-cell') && this.headerCells.indexOf(cell) === 0) {
            this.selectAll();
            return;
        }
        if (cell && !cell.element.classList.contains('grid-header-cell')) {
            this.startCell = cell;
            if (e.shiftKey) {
                this.selectRange(cell);
            } else if (e.ctrlKey || e.metaKey) {
                this.toggleCellSelection(cell);
            } else {
                this.clearSelection();
                this.selectCell(cell);
                this.editCell(cell);
            }
        }
    }

    private handleMouseMove(e: MouseEvent) {
        if (!this.isDragging || !this.startCell) return;
        const cell = this.getCellFromElement(e.target as HTMLDivElement);
        if (cell) {
            this.selectRange(cell);
        }
    }

    private handleMouseUp() {
        this.isDragging = false;
        this.startCell = null;
    }

    private handleKeyDown(e: KeyboardEvent) {
        let activeCell: Cell | null = null;
        for (const row of this.cells) {
            for (const cell of row) {
                if (cell.element === document.activeElement) {
                    activeCell = cell;
                    break;
                }
            }
            if (activeCell) break;
        }
        if (!activeCell) return;

        let row = -1;
        let col = -1;
        for (let i = 0; i < this.cells.length; i++) {
            const cellRow = this.cells[i];
            const cellIndex = cellRow.indexOf(activeCell);
            if (cellIndex !== -1) {
                row = i;
                col = cellIndex;
                break;
            }
        }

        switch (e.key) {
            case 'ArrowUp':
                row = Math.max(0, row - 1);
                break;
            case 'ArrowDown':
                row = Math.min(this.config.rows - 1, row + 1);
                break;
            case 'ArrowLeft':
                col = Math.max(0, col - 1);
                break;
            case 'ArrowRight':
                col = Math.min(this.config.cols - 1, col + 1);
                break;
            case 'Tab':
                col = (col + 1) % this.config.cols;
                if (col === 0) {
                    row = Math.min(this.config.rows - 1, row + 1);
                }
                break;
            case 'Enter':
                this.editCell(activeCell);
                e.preventDefault();
                return;
            case 'Escape':
                this.cancelEdit(activeCell);
                e.preventDefault();
                return;
            default:
                return;
        }
        this.clearSelection();
        this.selectCell(this.cells[row][col]);
        this.cells[row][col].element.focus();
    }

    private handleDoubleClick(e: MouseEvent) {
        const cell = this.getCellFromElement(e.target as HTMLDivElement);
        if (cell && !cell.element.classList.contains('grid-header-cell')) {
            this.editCell(cell);
        }
    }

    private handleCopy(e: ClipboardEvent) {
        this.copiedCells = [];
        for (const row of this.cells) {
            for (const cell of row) {
                if (cell.selected) {
                    this.copiedCells.push(cell);
                }
            }
        }
        if (this.copiedCells.length === 0) return;
        e.preventDefault();
        const text = this.copiedCells.map(cell => cell.value).join('\t');
        e.clipboardData?.setData('text/plain', text);
    }

    private handlePaste(e: ClipboardEvent) {
        const text = e.clipboardData?.getData('text/plain');
        if (!text) return;
        e.preventDefault();
        const values = text.split('\t');
        let index = 0;
        for (const row of this.cells) {
            for (const cell of row) {
                if (cell.selected) {
                    cell.value = values[index] || '';
                    cell.element.textContent = cell.value;
                    this.emitCellValueChange(cell);
                    index++;
                }
            }
        }
    }

    private handleResizeStart(e: MouseEvent) {
        if (!(e.target instanceof HTMLDivElement) || !e.target.classList.contains('resize-handle')) return;
        this.resizeHandle = e.target;
        const headerCell = this.getCellFromElement(this.resizeHandle.parentElement as HTMLDivElement);
        if (!headerCell) return;
        this.resizingColIndex = this.headerCells.indexOf(headerCell);
        this.startX = e.clientX;
        const grid = this.container;
        this.startWidth = parseInt(getComputedStyle(grid).gridTemplateColumns.split(' ')[this.resizingColIndex]);
    }

    private handleResizeMove(e: MouseEvent) {
         if (this.resizingColIndex === null) return;
        const width = e.clientX - this.startX;
        this.resizeColumn(this.resizingColIndex, width);
    }

    private handleResizeEnd() {
        this.resizingColIndex = null;
        this.resizeHandle = null;
    }

    private resizeColumn(colIndex: number, width: number) {
        if (colIndex < 0 || colIndex >= this.config.cols) return;
        const grid = this.container;
        const newWidth = Math.max(50, this.startWidth + width);
        const gridTemplateColumns = getComputedStyle(grid).gridTemplateColumns.split(' ');
        gridTemplateColumns[colIndex] = `${newWidth}px`;
        grid.style.gridTemplateColumns = gridTemplateColumns.join(' ');
    }

    private getCellFromElement(element: HTMLDivElement): Cell | null {
         for (const cell of this.rowNumberCells) {
            if (cell.element === element) {
                return cell;
            }
        }
        for (const row of this.cells) {
            for (const cell of row) {
                if (cell.element === element) {
                    return cell;
                }
            }
        }
        for (const cell of this.headerCells) {
            if (cell.element === element) {
                return cell;
            }
        }
        return null;
    }

    private selectCell(cell: Cell) {
        cell.selected = true;
        cell.element.classList.add('selected');
    }

    private toggleCellSelection(cell: Cell) {
        cell.selected = !cell.selected;
        cell.element.classList.toggle('selected');
    }

    private clearSelection() {
        for (const row of this.cells) {
            for (const cell of row) {
                cell.selected = false;
                cell.element.classList.remove('selected');
            }
        }
        for (const cell of this.rowNumberCells) {
            cell.selected = false;
            cell.element.classList.remove('selected');
        }
    }

    private selectRange(endCell: Cell) {
        if (!this.startCell) return;
        let startRow = -1;
        let startCol = -1;
        for (let i = 0; i < this.cells.length; i++) {
            const cellRow = this.cells[i];
            const cellIndex = cellRow.indexOf(this.startCell);
            if (cellIndex !== -1) {
                startRow = i;
                startCol = cellIndex;
                break;
            }
        }

        let endRow = -1;
        let endCol = -1;
         for (let i = 0; i < this.cells.length; i++) {
            const cellRow = this.cells[i];
            const cellIndex = cellRow.indexOf(endCell);
            if (cellIndex !== -1) {
                endRow = i;
                endCol = cellIndex;
                break;
            }
        }

        this.clearSelection();

        const rowStart = Math.min(startRow, endRow);
        const rowEnd = Math.max(startRow, endRow);
        const colStart = Math.min(startCol, endCol);
        const colEnd = Math.max(startCol, endCol);

        for (let row = rowStart; row <= rowEnd; row++) {
            for (let col = colStart; col <= colEnd; col++) {
                this.selectCell(this.cells[row][col]);
            }
        }
    }

    private editCell(cell: Cell) {
        if (cell.editing) return;
        cell.editing = true;
        cell.element.contentEditable = 'true';
        cell.element.focus();
        cell.element.addEventListener('blur', () => this.handleCellBlur(cell), { once: true });
    }

    private cancelEdit(cell: Cell) {
        if (!cell.editing) return;
        cell.editing = false;
        cell.element.contentEditable = 'false';
        cell.element.textContent = cell.value;
    }

    private handleCellBlur(cell: Cell) {
        if (!cell.editing) return;
        cell.editing = false;
        cell.value = cell.element.textContent || '';
        cell.element.contentEditable = 'false';
        this.emitCellValueChange(cell);
    }

    private async emitCellValueChange(cell: Cell) {
        // Simulate async operation
        await new Promise(resolve => setTimeout(resolve, 0));
        console.log('Cell value changed:', cell.value);
    }

    public setColumnTitle(col: number, title: string) {
        if (col < 0 || col >= this.headerCells.length -1) return;
        this.headerCells[col + 1].element.textContent = title;
    }

    private selectAll() {
        this.clearSelection();
        for (const row of this.cells) {
            for (const cell of row) {
                this.selectCell(cell);
            }
        }
    }
}